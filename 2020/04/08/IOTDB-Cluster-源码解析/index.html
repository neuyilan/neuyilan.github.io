<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=6.7.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.7.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.7.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.7.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.7.0',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文从源码的角度介绍了IOTDB的分布式模块。">
<meta name="keywords" content="IoTDB,cluster">
<meta property="og:type" content="article">
<meta property="og:title" content="IOTDB-Cluster 源码解析">
<meta property="og:url" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/index.html">
<meta property="og:site_name" content="yilan">
<meta property="og:description" content="本文从源码的角度介绍了IOTDB的分布式模块。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/Log.png">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/Snapshot.png">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/函数接口的实现.png">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/Applier.png">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/LogManager.png">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/RaftServer.png">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/RaftMember.png">
<meta property="og:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/partition划分图解.png">
<meta property="og:updated_time" content="2021-04-20T09:10:31.630Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IOTDB-Cluster 源码解析">
<meta name="twitter:description" content="本文从源码的角度介绍了IOTDB的分布式模块。">
<meta name="twitter:image" content="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/Log.png">






  <link rel="canonical" href="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>IOTDB-Cluster 源码解析 | yilan</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yilan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://neuyilan.github.io/2020/04/08/IOTDB-Cluster-源码解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="伊蓝">
      <meta itemprop="description" content="记录点滴">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yilan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">IOTDB-Cluster 源码解析

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-04-08 16:50:52" itemprop="dateCreated datePublished" datetime="2020-04-08T16:50:52+08:00">2020-04-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2021-04-20 17:10:31" itemprop="dateModified" datetime="2021-04-20T17:10:31+08:00">2021-04-20</time>
              
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/04/08/IOTDB-Cluster-源码解析/#comments" itemprop="discussionUrl">
                  <span class="post-meta-item-text">评论数：</span> <span class="post-comments-count valine-comment-count" data-xid="/2020/04/08/IOTDB-Cluster-源码解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文从源码的角度介绍了IOTDB的分布式模块。<br><a id="more"></a></p>
<h1 id="Log-相关"><a href="#Log-相关" class="headerlink" title="Log 相关"></a>Log 相关</h1><h2 id="log"><a href="#log" class="headerlink" title="log"></a>log</h2><p>log记录了集群中发生过的操作，每一条log都有如下4个变量：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>currLogIndex</td>
<td>此条log的索引</td>
<td></td>
</tr>
<tr>
<td>currLogTerm</td>
<td>此条log的term</td>
<td></td>
</tr>
<tr>
<td>previousLogIndex</td>
<td>前一条log的索引</td>
<td></td>
</tr>
<tr>
<td>previousLogTerm</td>
<td>前一条log的term</td>
<td></td>
</tr>
</tbody>
</table>
<!--more-->
<p><img src="Log.png" alt="log"><br>类图非常清晰了，无需详细解析，目前支持4种类型的log：1.AddNodeLog; 2.RemoveNodeLog; 3.CloseFileLog; 4.PhysicalPlanLog</p>
<h2 id="snapshot解析"><a href="#snapshot解析" class="headerlink" title="snapshot解析"></a>snapshot解析</h2><p><img src="Snapshot.png" alt="snapshot"></p>
<ol>
<li>所有的snapshot都继承自父类Snapshot，父类有两个成员变量：lastLogIndex和lastLogTerm，指的是快照中最后的一条logid和log term</li>
<li>SimpleSnapshot： 是最简单的快照实现方式，所有的log都保存在内存中，快照是一个list<log>的数组实现方式。</log></li>
<li>FileSnapshot：继承了Snapshot的同时，也实现了TimeseriesSchemaSnapshot接口，主要保存了两个属性：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private Collection&lt;MeasurementSchema&gt; timeseriesSchemas</span><br><span class="line">private List&lt;RemoteTsFileResource&gt;  dataFiles</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>RemoteTsFileResource是tsfile的文件描述，而MeasurementSchema也是描述的各个measurement。所以可以看出来FileSnapshot之所以称之为”文件快照“，主要是由于保存了TsFileResource的原因。</p>
<ol start="4">
<li><p>PullSnapshotTaskDescriptor：首先看一下官方注释：<strong>PullSnapshotTaskDescriptor describes a pull-snapshot-task with the slots to pull.</strong>， 有如下两个数据结构.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private PartitionGroup previousHolders;</span><br><span class="line">private List&lt;Integer&gt; slots;</span><br></pre></td></tr></table></figure>
</li>
<li><p>PartitionedSnapshot: 使用一个map保存了每个slot id对应的快照。核心数据结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// key是slot id，value是Snapshot的泛型(具体的某一种Snapshot)</span><br><span class="line">private Map&lt;Integer, T&gt; slotSnapshots;</span><br><span class="line">// SnapshotFactory是一个函数式接口，用来反序列化的时候创建Snapshot的实例，</span><br><span class="line">// 可以通过下图看到函数接口的实现都是Snapshot的默认构造函数。</span><br><span class="line">private SnapshotFactory&lt;T&gt; factory;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><img src="函数接口的实现.png" alt="函数接口的实现"></p>
<ol start="6">
<li>MetaSimpleSnapshot：继承自SimpleSnapshot：多了一个属性storageGroups，保存了所有的storageGroups。除了需要保存storageGroups之外，MetaSimpleSnapshot还需要保存所有需要的元数据，例如ttl，dataAuth等。</li>
<li>PullSnapshotTask， 他并不是一个快照的实现类，而是封装了执行快照任务的一个类，它实现了Callable接口，可以简单的理解为实现了Runnable接口一样，关于Runnable和Callable接口的差异请google。call 函数是具体实现pullSnapshot 任务的函数，返回值是一个map，key是slot id，value是snapshot，以供调用者可以读取snapshot的数据来进行数据追赶。PullSnapshotTask持有PullSnapshotTaskDescriptor，用来描述从哪儿拉取快照。</li>
</ol>
<h2 id="log-applier"><a href="#log-applier" class="headerlink" title="log applier"></a>log applier</h2><p><img src="Applier.png" alt="Applier"><br>核心函数就是apply(Log)，使得log所描述的action在本机生效，这里其实跟wal有点类似了，wal的作用就是执行任何事情之前先写wal，防止崩溃的时候wal可以恢复，只不过log applier是raft状态机中的组件。</p>
<p>DataLogApplier目前提供的apply类型：PhysicalPlanLog和CloseFileLog<br>MetaLogApplier目前提供的apply类型：AddNodeLog，RemoveNodeLog和PhysicalPlanLog。</p>
<p>两种都提供PhysicalPlanLog，会根据具体提供的操作(数据操作、元数据操作)不一样而执行不同的方法。</p>
<h2 id="log-manager"><a href="#log-manager" class="headerlink" title="log manager"></a>log manager</h2><p><img src="LogManager.png" alt="LogManager"><br>log manager也就是管理log的一些类，也就是log 存在哪里，怎么存？怎么取？等，目前的实现都是基于内存的实现方式。如果一个复制组所有的节点都crash的话，则log也就丢失了，基于文件(可持久化)的log管理目前正在开发中(<a href="https://issues.apache.org/jira/browse/IOTDB-351" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/IOTDB-351</a>)</p>
<ol>
<li><p>LogManager接口，主要提供了一些访问Log类属性的一些方法以及存储，读取log的一些函数。其中着重指出void commitLog(long maxLogIndex)函数，此函数会调用log applier中的apply函数。主要函数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 追加一条log，目前实现是在内存中的logbuffer中追加一条log，</span><br><span class="line">// 并且更新lastLogId以及lastLogTgiterm</span><br><span class="line">boolean appendLog(Log log);</span><br><span class="line"></span><br><span class="line">// 应用(apply) maxLogIndex之前的所有的日志</span><br><span class="line">void commitLog(long maxLogIndex);</span><br><span class="line"></span><br><span class="line">// 用于判断logIndex这条log是否还在内存中，如果不在内存中，说明已经形成快照了</span><br><span class="line">boolean logValid(long logIndex);</span><br><span class="line"></span><br><span class="line">Snapshot getSnapshot();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Take a snapshot of the committed logs instantly and discard the committed logs.</span><br><span class="line"> */</span><br><span class="line">// 把commitIndex之前的日志形成快照，并且删除commitIndex之前的日志。</span><br><span class="line">void takeSnapshot() throws IOException;</span><br><span class="line"></span><br><span class="line">LogApplier getApplier();</span><br><span class="line"></span><br><span class="line">void setLastLogId(long lastLogId);</span><br><span class="line"></span><br><span class="line">void setLastLogTerm(long lastLogTerm);</span><br></pre></td></tr></table></figure>
</li>
<li><p>MemoryLogManager，虚类，把所有的log都保存在内存中。</p>
</li>
<li>MetaSingleSnapshotLogManager， 继承自MemoryLogManager，其中的snapshot也是内存持有的，不过其getSnapshot函数返回的是MetaSimpleSnapshot。</li>
<li>PartitionedSnapshotLogManager， 继承自MemoryLogManager，其中的snapshot也是内存持有的，不过其getSnapshot函数返回的是PartitionedSnapshot。<font color="red">实际中没有</font></li>
<li>FilePartitionedSnapshotLogManager，继承自PartitionedSnapshotLogManager，与PartitionedSnapshotLogManager不同之处在于：PartitionedSnapshotLogManager在更新快照的时候会把快照保存在内存中，而FilePartitionedSnapshotLogManager想从tsfile中实时获取快照。笔者理解就是FilePartitionedSnapshotLogManager不想在内存中保存快照，而是在需要的时候实时从tsfile中获取快照，用以减少内存的使用。<strong>但是目前并未达到理想的效果，因为在LogManager append log的时候，已经把log保存在内存中了，所以iotdb作者起了一个issue来研究这个问题 <a href="https://issues.apache.org/jira/browse/IOTDB-439" target="_blank" rel="noopener">https://issues.apache.org/jira/browse/IOTDB-439</a></strong></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Log,LogManager和LogApplier以及Snapshot之间的关系几个组件的关系为：</p>
<ul>
<li>LogManager管理了log，包括log的存储，读取；</li>
<li>LogManager调用了LogApplier来执行真正的操作；</li>
<li>Snapshot是一种特殊的log，为了解决log过多的问题，Snapshot主要有三种：<ol>
<li>包含了一组log的集合(目前实现是保存在内存中);</li>
<li>包含了一组tsfile(文件的snapshot)的集合;</li>
<li>包含了一些元数据集合的MetaSimpleSnapshot。</li>
</ol>
</li>
</ul>
<h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p><img src="RaftServer.png" alt="RaftServer"><br>先看一下UML类图，一图胜千言，RaftServer是一个虚类，里面的函数主要是根据一些节点的配置（ip，port）等进行初始化，然后启动服务。其有两个子类，一个是DataClusterServer,主要负责data 操作相关的事情，然后通过rpc传到同一个raft组的其他节点上；另外一个是MetaClusterServer，主要负责meta数据的操作，然后把操作通过rpc传到同一个raft组的其他节点上。</p>
<h2 id="RaftServer"><a href="#RaftServer" class="headerlink" title="RaftServer"></a>RaftServer</h2><p>主要包括两个大的功能：1. 初始化节点配置；2. 启动节点并且监听rpc端口服务(start()函数)</p>
<h2 id="MetaClusterServer"><a href="#MetaClusterServer" class="headerlink" title="MetaClusterServer"></a>MetaClusterServer</h2><p>首先看一下官方注释：<strong>MetaCluster manages the whole cluster’s metadata, such as what nodes are in the cluster and the data partition. Each node has one MetaClusterServer instance, the single-node IoTDB instance is started-up at the same time.</strong> 意思就是MetaClusterServer管理了集群中所有的meta信息，主要信息就是数据的分布了(后面会详细讲解节点的分布策略)。每个节点上都会有和一个MetaClusterServer实例（<font color="red">也就是说iotdb的cluster版本每个节点是同质的，假设有1000个节点，则1000个节点上都有meta服务，1000个节点组成了meta信息的raft复制组。这在性能，结果一致性上面还是有问题的</font>），同时也会启动一个iotdb的实例。</p>
<p>MetaClusterServer主要变量如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 每个clusterServer会有一个MetaGroupMember对象，后面会详细介绍。</span><br><span class="line">private MetaGroupMember member;</span><br><span class="line">// iotdb实例</span><br><span class="line">private IoTDB  ioTDB;</span><br><span class="line">// 保存cluster集群一些状态，在此先不做详细介绍。</span><br><span class="line">private RegisterManager registerManager = new RegisterManager();</span><br></pre></td></tr></table></figure></p>
<h2 id="DataClusterServer"><a href="#DataClusterServer" class="headerlink" title="DataClusterServer"></a>DataClusterServer</h2><p>DataClusterServer的作用就是来管理data一些数据的操作的，与MetaClusterServer不同之处在于他的RaftMember是一个map，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// key 是raft 复制组的header node， value是DataGroupMember，也就代表了一个复制组。</span><br><span class="line">private Map&lt;Node, DataGroupMember&gt; headerGroupMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// 这个数据结构是关键，后面会详细讲解。</span><br><span class="line">private PartitionTable partitionTable;</span><br></pre></td></tr></table></figure></p>
<p>DataClusterServer的任何操作都是先要在这个map中根据rpc传过来的header，找到对应的DataGroupMember，然后再进行操作。</p>
<font color="red">todo@戚厚亮，后面记得讲解PartitionTable</font>

<h1 id="RaftMember"><a href="#RaftMember" class="headerlink" title="RaftMember"></a>RaftMember</h1><p><img src="RaftMember.png" alt="RaftMember"><br>先上一个官方注释。<br><strong>RaftMember process the common raft logic like leader election, log appending, catch-up and so on.</strong> 也就是说，raft算法中的一些核心逻辑：领导选举、log复制、快照追赶等逻辑都是RaftMember干的。</p>
<p>下面介绍一下核心属性的作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// the name of the member, to distinguish several members from the logs</span><br><span class="line">// name就是“META/DATA”+ip+port</span><br><span class="line">String name;</span><br><span class="line"></span><br><span class="line">// to choose nodes to join cluster request randomly</span><br><span class="line">// 当有新的节点加入到集群中的时候，从已经在集群中的节点中随机的选择一个节点来处理加入操作。</span><br><span class="line">Random random = new Random();</span><br><span class="line"></span><br><span class="line">protected Node thisNode;</span><br><span class="line">// the nodes known by this node</span><br><span class="line">protected volatile List&lt;Node&gt; allNodes;</span><br><span class="line"></span><br><span class="line">AtomicLong term = new AtomicLong(0);</span><br><span class="line">// 默认开始都是ELECTOR的状态</span><br><span class="line">volatile NodeCharacter character = NodeCharacter.ELECTOR;</span><br><span class="line">volatile Node leader;</span><br><span class="line">volatile long lastHeartbeatReceivedTime;</span><br><span class="line"></span><br><span class="line">// the raft logs are all stored and maintained in the log manager</span><br><span class="line">// logManager管理了所有的log操作，详细分析请看上面logManager</span><br><span class="line">LogManager logManager;</span><br><span class="line"></span><br><span class="line">// the single thread pool that runs the heartbeat thread</span><br><span class="line">// 心跳线程池，其心跳服务在HeartbeatThread类中。</span><br><span class="line">ExecutorService heartBeatService;</span><br><span class="line"></span><br><span class="line">// the thread pool that runs catch-up tasks</span><br><span class="line">// catch up线程池</span><br><span class="line">private ExecutorService catchUpService;</span><br><span class="line"></span><br><span class="line">// lastCatchUpResponseTime records when is the latest response of each node&apos;s catch-up. There</span><br><span class="line">// should be only one catch-up task for each node to avoid duplication, but the task may time out and in that case, the next catch up should be enabled.</span><br><span class="line">// 记录节点上次追赶log的时间，用于防止一个节点建立多个追赶任务，也用于判断追赶日志超时使用。</span><br><span class="line">private Map&lt;Node, Long&gt; lastCatchUpResponseTime = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">// the pool that provides reusable clients to connect to other RaftMembers. It will be initialized according to the implementation of the subclasses</span><br><span class="line">// client 连接池，用于复用已经创建的连接，不用每次通信都需要建立连接</span><br><span class="line">private ClientPool clientPool;</span><br><span class="line"></span><br><span class="line">// when the commit progress is updated by a heart beat, this object is notified so that we may</span><br><span class="line">// know if this node is synchronized with the leader</span><br><span class="line">// 两个地方用到了这个锁；1.syncLeader函数，用来同步leader的commint log index的。2.在心跳算法sendHeartbeat中，也是用来同步leader 的commit log index的。</span><br><span class="line">private Object syncLock = new Object();</span><br><span class="line"></span><br><span class="line">// when the header of the group is removed from the cluster, the members of the group should no longer accept writes, but they still can be read candidates for weak consistency reads and  provide snapshots for the new holders</span><br><span class="line">volatile boolean readOnly = false;</span><br></pre></td></tr></table></figure></p>
<font color="red">这里要强调一下上面的allNodes变量，这里的allNodes并不是所有的节点，而仅仅是这个复制组里面的节点，通常节点个数与副本数一致 </font>

<h2 id="RaftMember中的重点函数解析"><a href="#RaftMember中的重点函数解析" class="headerlink" title="RaftMember中的重点函数解析"></a>RaftMember中的重点函数解析</h2><p>首先明确一点，心跳是leader发送给follower的。发送的内容是leader的commitLogTerm和commitLogIndex，来让follower更新自己的commitLogTerm和commitLogIndex。</p>
<h3 id="心跳算法"><a href="#心跳算法" class="headerlink" title="心跳算法"></a>心跳算法</h3><ol>
<li>如果follower收到的请求的term小于本地节点的term，则拒绝这次心跳请求，并且把本地节点保存的term返回给发送者，让leader更新自己的状态。</li>
<li>如果校验心跳请求参数合格的话，则会把本节点log最后更新的index发送给leader，让leader知道下次给”我”这个节点发送log的时候从哪里开始发送。</li>
<li>执行回调HeartbeatHandler.onComplete。leader会根据返回的信息做如下几个事情：<ul>
<li><font color="red"> 如果follower还承认我是leader，则根据follower发送过来的logIndex让follower追赶我的日志 </font>，注意LogCatchUpTask和SnapshotCatchUpTask都是leader主动给follower发送数据的，让follower进行追赶leader的日志(快照)。</li>
<li>如果follower的term比我leader的term还大，则leader主动发起退休(retireFromLeader)。</li>
</ul>
</li>
</ol>
<p>备注：此函数中有一个syncLock锁，是用来同步leader的CommitLogIndex的，只所以用锁是因为在<strong>syncLeader函数</strong>中也有同步leader的CommitLogIndex的的功能。</p>
<p>小提示：与etcd raft中心跳算法的不同之处在于：ectd raft心跳仅仅是leader把commitLogIndex发送给其他follower，并未返回一些信息让leader发起follower.catchUp的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Process the HeartBeatRequest from the leader. If the term of the leader is smaller than the</span><br><span class="line"> * local term, turn it down and tell it the newest term. ELse if the local logs catch up the</span><br><span class="line"> * leader&apos;s, commit them. Else help the leader find the last match log. Also update the</span><br><span class="line"> * leadership, heartbeat timer and term of the local node.</span><br><span class="line"> *</span><br><span class="line"> * @param request</span><br><span class="line"> * @param resultHandler</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void sendHeartbeat(HeartBeatRequest request, AsyncMethodCallback resultHandler) &#123;</span><br><span class="line">  logger.trace(&quot;&#123;&#125; received a heartbeat&quot;, name);</span><br><span class="line">  // term可以理解为一个全局锁</span><br><span class="line">  synchronized (term) &#123;</span><br><span class="line">    long thisTerm = term.get();</span><br><span class="line">    // 解析request中的数据，主要有leader的term</span><br><span class="line">    long leaderTerm = request.getTerm();</span><br><span class="line">    HeartBeatResponse response = new HeartBeatResponse();</span><br><span class="line"></span><br><span class="line">    // 如果leader的term比这个复制组的本节点的term小，则这个leader一定是过期的，忽略这个请求。并且把本节点的term告诉leader</span><br><span class="line">    if (leaderTerm &lt; thisTerm) &#123;</span><br><span class="line">      // a leader with term lower than this node is invalid, send it the local term to inform this</span><br><span class="line">      response.setTerm(thisTerm);</span><br><span class="line">      if (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(&quot;&#123;&#125; received a heartbeat from a stale leader &#123;&#125;&quot;, name, request.getLeader());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // the heartbeat comes from a valid leader, process it with the sub-class logic</span><br><span class="line">      processValidHeartbeatReq(request, response);</span><br><span class="line"></span><br><span class="line">      response.setTerm(Response.RESPONSE_AGREE);</span><br><span class="line">      // tell the leader who I am in case of catch-up</span><br><span class="line">      response.setFollower(thisNode);</span><br><span class="line">      // TODO-CLuster: the log being sent should be chosen wisely instead of the last log, so that the leader would be able to find the last match log</span><br><span class="line">      // 注释已经说的很好了，发送给leader的log应该让leader知道下次发送给follwer的index是多少！</span><br><span class="line">      response.setLastLogIndex(logManager.getLastLogIndex());</span><br><span class="line">      response.setLastLogTerm(logManager.getLastLogTerm());</span><br><span class="line"></span><br><span class="line">      // The term of the last log needs to be the same with leader&apos;s term in order to preserve safety, otherwise it may come from an invalid leader and is not committed</span><br><span class="line">      if (logManager.getLastLogTerm() == leaderTerm) &#123;</span><br><span class="line">        // syncLock只有两个地方有使用，除了此处之外，还在syncLeader函数中用到了，这里加这个锁就是防止本节点获取的leader信息是过时的。</span><br><span class="line">        synchronized (syncLock) &#123;</span><br><span class="line">          logManager.commitLog(request.getCommitLogIndex());</span><br><span class="line">          syncLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // if the log is not consistent, the commitment will be blocked until the leader makes the node catch up</span><br><span class="line"></span><br><span class="line">      term.set(leaderTerm);</span><br><span class="line">      setLeader(request.getLeader());</span><br><span class="line">      if (character != NodeCharacter.FOLLOWER) &#123;</span><br><span class="line">        setCharacter(NodeCharacter.FOLLOWER);</span><br><span class="line">      &#125;</span><br><span class="line">      setLastHeartbeatReceivedTime(System.currentTimeMillis());</span><br><span class="line">      if (logger.isTraceEnabled()) &#123;</span><br><span class="line">        logger.trace(&quot;&#123;&#125; received heartbeat from a valid leader &#123;&#125;&quot;, name, request.getLeader());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resultHandler.onComplete(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="catchUp函数"><a href="#catchUp函数" class="headerlink" title="catchUp函数"></a>catchUp函数</h3><p>在心跳算法中讲到leader发起heartBeat请求的时候，会有一个回调，即HeartbeatHandler.onComplete，在这里面会有执行catchUp方法。下面分析下这个函数。</p>
<p>catchUp函数也是leader主动发起的。当leader给follower发送心跳的时候，follower会把自己的lastLogIndex返回给leader，leader据此来发起catchUp操作，给follower推送lastLogIndex之后的所有的数据。</p>
<p>流程如下</p>
<ol>
<li>首先检查一下follower上次catchUp的时间距离现在是否小于一个阈值(20000ms)，如果是则不进行catchUp。(限制catchUp的时间间隔，心跳是1000ms)，</li>
<li>判断内存中log信息是否有效，有效的定义如下：要请求的日志都在内存中则视为有效(即follower还未落下很远，无需通过拉取快照进行追赶)。</li>
<li>构造follower所需的数据，根据第2步是否有效执行如下不同的内容。<ul>
<li>若2有效，则通过logManager获取followerLastLogIndex之后的所有日志；</li>
<li>若2无效，则证明follower所需的日志有些已经成为快照了，所以需要拉取快照和内存中日志两部分数据。</li>
</ul>
</li>
<li>向catchUpService服务(catchUpService是一个ExecutorService的线程池)中提交一个任务，任务根据第2步是否有效分为两种：(LogCatchUpTask和SnapshotCatchUpTask都实现了Runnable接口)<ul>
<li>若2有效：则会创建一个LogCatchUpTask任务。这个任务就是与follower建立连接，并且遍历所有需要追赶的log，执行followr.appendEntry()即可。<font color="red"> 注意：这里有一个优化点：可以调用followr.appendEntries()一次性把所有的log发送给follower，而不是每次都发送一条数据。</font></li>
<li>若2无效：则会创建一个SnapshotCatchUpTask任务。SnapshotCatchUpTask继承了LogCatchUpTask，其run方法主要内容如下：<ol>
<li>把第3步中构造的快照序列化之后调用follower.sendSnapshot发送给follower；</li>
<li>发送log：执行LogCatchUpTask中doLogCatchUp，即上面讲的LogCatchUpTask类中的主要内容。</li>
</ol>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Update the followers&apos; log by sending logs whose index &gt;= followerLastMatchedLogIndex to the</span><br><span class="line"> * follower. If some of the logs are not in memory, also send the snapshot.</span><br><span class="line"> * &lt;br&gt;notice that if a part of data is in the snapshot, then it is not in the logs&lt;/&gt;</span><br><span class="line"> *</span><br><span class="line"> * @param follower</span><br><span class="line"> * @param followerLastLogIndex</span><br><span class="line"> */</span><br><span class="line">public void catchUp(Node follower, long followerLastLogIndex) &#123;</span><br><span class="line">  // TODO-Cluster: use lastMatchLogIndex instead of lastLogIndex</span><br><span class="line">  // for one follower, there is at most one ongoing catch-up</span><br><span class="line">  synchronized (follower) &#123;</span><br><span class="line">    // check if the last catch-up is still ongoing</span><br><span class="line">    // 首先检查一下follower上次catchUp的时间距离现在是否小于一个阈值(20000ms)，如果是则不进行catchUp</span><br><span class="line">    Long lastCatchupResp = lastCatchUpResponseTime.get(follower);</span><br><span class="line">    if (lastCatchupResp != null</span><br><span class="line">        &amp;&amp; System.currentTimeMillis() - lastCatchupResp &lt; RaftServer.connectionTimeoutInMS) &#123;</span><br><span class="line">      logger.debug(&quot;&#123;&#125;: last catch up of &#123;&#125; is ongoing&quot;, name, follower);</span><br><span class="line">      return;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // record the start of the catch-up</span><br><span class="line">      lastCatchUpResponseTime.put(follower, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (followerLastLogIndex == -1) &#123;</span><br><span class="line">    // if the follower does not have any logs, send from the first one</span><br><span class="line">    followerLastLogIndex = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 连接到远程节点</span><br><span class="line">  AsyncClient client = connectNode(follower);</span><br><span class="line">  if (client != null) &#123;</span><br><span class="line">    List&lt;Log&gt; logs;</span><br><span class="line">    boolean allLogsValid;</span><br><span class="line">    Snapshot snapshot = null;</span><br><span class="line">    synchronized (logManager) &#123;</span><br><span class="line">      // check if the very first log has been snapshot</span><br><span class="line">      // 根据follower请求的logIndex判断要请求的所有log是否都在内存中，如果都在内存中，则只需要把内存中的log发送给follower即可，否则还需要把snapshot一起发送给follower</span><br><span class="line">      allLogsValid = logManager.logValid(followerLastLogIndex);</span><br><span class="line">      logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);</span><br><span class="line">      // 所需要的数据不都在内存中，所以需要把快照数据发送给follower。</span><br><span class="line">      if (!allLogsValid) &#123;</span><br><span class="line">        // if the first log has been snapshot, the snapshot should also be sent to the</span><br><span class="line">        // follower, otherwise some data will be missing</span><br><span class="line">        // 获取snapshot</span><br><span class="line">        snapshot = logManager.getSnapshot();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据是否需要给follower发送snapshot，生成LogCatchUpTask或是SnapshotCatchUpTask</span><br><span class="line">    if (allLogsValid) &#123;</span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;&#123;&#125; makes &#123;&#125; catch up with &#123;&#125; cached logs&quot;, name, follower, logs.size());</span><br><span class="line">      &#125;</span><br><span class="line">      catchUpService.submit(new LogCatchUpTask(logs, follower, this));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      logger.debug(&quot;&#123;&#125;: Logs in &#123;&#125; are too old, catch up with snapshot&quot;, name, follower);</span><br><span class="line">      catchUpService.submit(new SnapshotCatchUpTask(logs, snapshot, follower, this));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    lastCatchUpResponseTime.remove(follower);</span><br><span class="line">    logger.warn(&quot;&#123;&#125;: Catch-up failed: node &#123;&#125; is currently unavailable&quot;, name, follower);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选举算法"><a href="#选举算法" class="headerlink" title="选举算法"></a>选举算法</h3><p>处理选举过程的算法也很简单：</p>
<ol>
<li>首先看发送过来的请求的node(也就是要当leader的node)是否与本地节点保存的leader一致，如果一致我就同意。</li>
<li>如果不一致，则根据请求过来的信息与本地信息进行对比来决定是否同意发起选举的节点作为leader，其算法在processElectionRequest中。主要判断逻辑如下：<ul>
<li>thatTerm &lt;= thisTerm 拒绝，发起选举的term都比我本地的要小，怎么可能给你投票！</li>
<li>thatLastLogTerm &lt; thisLastLogTerm 拒绝，发起选举的节点的最后一条日志的term都比我本地的要小，拒绝你。</li>
<li>(thatLastLogTerm == thisLastLogTerm &amp;&amp; thatLastLogId &lt; thisLastLogIndex) 拒绝，虽然最后一条日志的term一致，但是发起选举节点的最后一条日志的索引比我本地的要小，拒绝你。</li>
<li>其他情况下就给发起选举的节点投票了。</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Process an ElectionRequest. If the request comes from the last leader, agree with it. Else</span><br><span class="line"> * decide whether to accept by examining the log status of the elector.</span><br><span class="line"> *</span><br><span class="line"> * @param electionRequest</span><br><span class="line"> * @param resultHandler</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void startElection(ElectionRequest electionRequest, AsyncMethodCallback resultHandler) &#123;</span><br><span class="line">  synchronized (term) &#123;</span><br><span class="line">    if (electionRequest.getElector().equals(leader)) &#123;</span><br><span class="line">      // always agree with the last leader</span><br><span class="line">      resultHandler.onComplete(Response.RESPONSE_AGREE);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // check the log status of the elector</span><br><span class="line">    long response = processElectionRequest(electionRequest);</span><br><span class="line">    logger.info(&quot;&#123;&#125; sending response &#123;&#125; to the elector &#123;&#125;&quot;, name, response,</span><br><span class="line">        electionRequest.getElector());</span><br><span class="line">    resultHandler.onComplete(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="syncLeader函数"><a href="#syncLeader函数" class="headerlink" title="syncLeader函数"></a>syncLeader函数</h3><p>在分析心跳算法的时候，在代码注释里面提到了syncLeader这个函数。这个函数主要用来同步leader的commint log index的。</p>
<ol>
<li>首先保证所有的快照下载任务都已经完成了。否则就等待所有的快照任务执行结束。</li>
<li>rpc与leader节点建立通信，请求CommitLogIndex。</li>
<li>判断本地的CommitLogIndex与leader的CommitLogIndex是否一致，即follwer是否追赶上了leader的日志。如果追赶上了，则返回成功；否则未超时的情况下(20秒)，等待心跳(默认1000ms，因为心跳的时候leader会使得follwer追赶自己的日志)。当等待超过20s之后若还未追赶上，则返回失败。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Request and check the leader&apos;s commitId to see whether this node has caught up. If not, wait</span><br><span class="line"> * until this node catches up.</span><br><span class="line"> *</span><br><span class="line"> * @return true if the node has caught up, false otherwise</span><br><span class="line"> */</span><br><span class="line">public boolean syncLeader() &#123;</span><br><span class="line">  // make sure all snapshot pulling are done, otherwise some data will remain in the old nodes</span><br><span class="line">  // 首先要保证所有的的下载快照任务都已经完成了</span><br><span class="line">  logManager.waitRemoteSnapshots();</span><br><span class="line"></span><br><span class="line">  if (character == NodeCharacter.LEADER) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  if (leader == null) &#123;</span><br><span class="line">    // the leader has not been elected, we must assume the node falls behind</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  logger.debug(&quot;&#123;&#125;: try synchronizing with the leader &#123;&#125;&quot;, name, leader);</span><br><span class="line">  long startTime = System.currentTimeMillis();</span><br><span class="line">  long waitedTime = 0;</span><br><span class="line">  AtomicReference&lt;Long&gt; commitIdResult = new AtomicReference&lt;&gt;(Long.MAX_VALUE);</span><br><span class="line">  // syncLeaderMaxWaitMs = 20 * 1000，也就是20s</span><br><span class="line">  while (waitedTime &lt; RaftServer.syncLeaderMaxWaitMs) &#123;</span><br><span class="line">    // 连接到leader节点</span><br><span class="line">    AsyncClient client = connectNode(leader);</span><br><span class="line">    if (client == null) &#123;</span><br><span class="line">      // cannot connect to the leader</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">      synchronized (commitIdResult) &#123;</span><br><span class="line">        // rpc调用，请求leader的commitIndex</span><br><span class="line">        client.requestCommitIndex(getHeader(), new GenericHandler&lt;&gt;(leader, commitIdResult));</span><br><span class="line">        commitIdResult.wait(RaftServer.syncLeaderMaxWaitMs);</span><br><span class="line">      &#125;</span><br><span class="line">      long leaderCommitId = commitIdResult.get();</span><br><span class="line">      long localCommitId = logManager.getCommitLogIndex();</span><br><span class="line">      logger.debug(&quot;&#123;&#125;: synchronizing commitIndex &#123;&#125;/&#123;&#125;&quot;, name, localCommitId, leaderCommitId);</span><br><span class="line">      // 判断本地的commitIndex是否已经追赶上leader的commitIndex</span><br><span class="line">      if (leaderCommitId &lt;= localCommitId) &#123;</span><br><span class="line">        // before the response comes, the leader may commit new logs and the localCommitId may be updated by catching up, so it is possible that localCommitId &gt; leaderCommitId at this time,this node has caught up</span><br><span class="line">        // 个人理解这种情况发生在requestCommitIndex请求还未返回的时候，leader提交了新的日志，并且也把这些日志同步给了follower。</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          waitedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">          logger.debug(&quot;&#123;&#125;: synchronized with the leader after &#123;&#125;ms&quot;, name, waitedTime);</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line">      // wait for next heartbeat to catch up</span><br><span class="line">      // the local node will not perform a commit here according to the leaderCommitId because</span><br><span class="line">      // the node may have some inconsistent logs with the leader</span><br><span class="line">      // 真是一个骚操作啊！！！！！等待heartbeat追赶日志？heartbeat还有这个功能，在心跳章节中解释了为什么心跳的时候还有日志追赶的功能。</span><br><span class="line">      waitedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">      synchronized (syncLock) &#123;</span><br><span class="line">        // heartBeatIntervalMs 1000ms</span><br><span class="line">        syncLock.wait(RaftServer.heartBeatIntervalMs);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (TException | InterruptedException e) &#123;</span><br><span class="line">      logger.error(&quot;&#123;&#125;: Cannot request commit index from &#123;&#125;&quot;, name, leader, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DataGroupMember"><a href="#DataGroupMember" class="headerlink" title="DataGroupMember"></a>DataGroupMember</h2><p>里面就是具体的功能实现了，<font color="green">// TODO</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* When a DataGroupMember pulls data from another node, the data files will be firstly stored in the &quot;REMOTE_FILE_TEMP_DIR&quot;, and then load file functionality of IoTDB will be used to load the files into the IoTDB instance.</span><br><span class="line">*/</span><br><span class="line">private static final String REMOTE_FILE_TEMP_DIR = &quot;remote&quot;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* The MetaGroupMember that in charge of the DataGroupMember. Mainly for providing partition table and MetaLogManager.</span><br><span class="line">*/</span><br><span class="line">private MetaGroupMember metaGroupMember;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* The thread pool that runs the pull snapshot tasks. Pool size is the # of CPU cores.</span><br><span class="line">*/</span><br><span class="line">private ExecutorService pullSnapshotService;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* &quot;logManager&quot; manages the logs of this DataGroupMember. Although the logs of different data partitions (slots) are mixed together before a snapshot is taken, after the taking of snapshot, logs of different logs will be stored separately.</span><br><span class="line">*/</span><br><span class="line">private PartitionedSnapshotLogManager logManager;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* &quot;queryManger&quot; records the remote nodes which have queried this node, and the readers or</span><br><span class="line">* executors this member has created for those queries. When the queries end, an</span><br><span class="line">* EndQueryRequest will be sent to this member and related resources will be released.</span><br><span class="line">*/</span><br><span class="line">private ClusterQueryManager queryManager;</span><br></pre></td></tr></table></figure></p>
<h2 id="MetaGroupMember"><a href="#MetaGroupMember" class="headerlink" title="MetaGroupMember"></a>MetaGroupMember</h2><p>里面就是具体的功能实现了，<font color="green">// TODO</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// nodes in the cluster and data partitioning</span><br><span class="line">// 重点是这个PartitionTable的实现，这里面包含了tsfile的数据分布，在partition章节将详细分析</span><br><span class="line"> private PartitionTable partitionTable;</span><br></pre></td></tr></table></figure></p>
<h3 id="详细函数分析"><a href="#详细函数分析" class="headerlink" title="详细函数分析"></a>详细函数分析</h3><p>####List<tsdatatype> getSeriesTypesByPath(List<path> paths, List<string> aggregations)<br>此函数的功能是获取paths中每个path所对应的tsDataType，函数思路：</string></path></tsdatatype></p>
<ol>
<li>从本地获取，如果本地有则返回，否则执行第2步骤；</li>
<li>从远端获取：<ul>
<li>先执行pullTimeSeriesSchemas(path) 获取这个path的schema，然后从schema中获取dataType。</li>
<li>把这些schema cache在本地。</li>
</ul>
</li>
</ol>
<font color="red">注意：此处有一个优化点：第1步从本地获取的时候，是批量执行的，即如果有一个path对应的schema在本地不存在，则这批操作都失败，然后都去远程去拿，其实可以优化为对于失败的那些去远程读取，这样会少远程读取的操作</font>

<h1 id="数据分布partition"><a href="#数据分布partition" class="headerlink" title="数据分布partition"></a>数据分布partition</h1><p>数据分布主要有以下几个类：</p>
<ol>
<li>PartitionGroup. 这个类继承了ArrayList<node>，所以实际上就是一个Node的列表，这个列表中所有的节点组成了一个raft复制组的所有节点，第一个节点记为header。</node></li>
<li>PartitionTable是一个interface，其实现是SlotPartitionTable，其核心就是如下几个属性</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//The following fields are used for determining which node a data item belongs to.</span><br><span class="line">// the slots held by each node</span><br><span class="line">// key:node，value是这个node上面所有的slot，slot就是tsfile的逻辑单位</span><br><span class="line">private Map&lt;Node, List&lt;Integer&gt;&gt; nodeSlotMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">// each slot is managed by whom</span><br><span class="line">// key:slot id，value是这个slot id所在的node</span><br><span class="line">private Map&lt;Integer, Node&gt; slotNodeMap = new ConcurrentHashMap&lt;&gt;();//TODO a List is enough</span><br><span class="line">// the nodes that each slot belongs to before a new node is added, used for the new node to find the data source</span><br><span class="line">private Map&lt;Node, Map&lt;Integer, Node&gt;&gt; previousNodeMap = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">//the filed is used for determining which nodes need to be a group. the data groups which this node belongs to.</span><br><span class="line">// localGroups保存了本节点上的所有的复制组</span><br><span class="line">private List&lt;PartitionGroup&gt; localGroups;</span><br></pre></td></tr></table></figure>
<p>下面详细讲解一下SlotPartitionTable中的一些函数</p>
<h2 id="SlotPartitionTable初始化"><a href="#SlotPartitionTable初始化" class="headerlink" title="SlotPartitionTable初始化"></a>SlotPartitionTable初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void init(Collection&lt;Node&gt; nodes) &#123;</span><br><span class="line">  logger.info(&quot;Initializing a new partition table&quot;);</span><br><span class="line">  nodeRing.addAll(nodes);</span><br><span class="line">  // 根据nodeIdentifier对所有的node进行排序，nodeIdentifier的生成是在MetaGroupMember::genNodeIdentifier()函数中，会根据ip，port和当前时间进行hash生成一个数字</span><br><span class="line">  nodeRing.sort(Comparator.comparingInt(Node::getNodeIdentifier));</span><br><span class="line">  // getPartitionGroups 这个函数算法详解在下面单独列出</span><br><span class="line">  localGroups = getPartitionGroups(thisNode);</span><br><span class="line">  assignPartitions();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="getPartitionGroups函数详解"><a href="#getPartitionGroups函数详解" class="headerlink" title="getPartitionGroups函数详解"></a>getPartitionGroups函数详解</h2><ol>
<li>首先找到这个节点的索引index（所有的节点都已经按照nodeIdentifier排序了）</li>
<li>找到这个节点的上面的所有的复制组，算法如下。<br><img src="partition划分图解.png" alt="partition 划分图解"><ul>
<li>首先把所有的节点按照索引大小排列为一个环，如下所示（假设有10个节点）,假设此节点的index为1，副本数replicaNum为3，则这个节点上面就会形成3个data group(复制组)</li>
<li>首先以节点1为起始点，顺时针找replicaNum个节点组成一个复制组，即节点1，2，3组成了一个复制组data group0，这个复制组的header为节点1；</li>
<li>然后在以节点0(节点1的上一个节点)为起始点，顺时针找replicaNum个节点组成一个复制组，即节点0，1，2组成了一个复制组data group1，这个复制组的header为节点0；</li>
<li>然后在以节点9(节点0的上一个节点)为起始点，顺时针找replicaNum个节点组成一个复制组，即节点9，0，1组成了和一个复制组data group2，这个复制组的header为节点9；</li>
</ul>
</li>
</ol>
<p>可以看到每个节点上面最多有replicaNum个复制组。getHeaderGroup(Node node)的作用就是以参数node为起始点，顺时针找到replicaNum个节点作为一个复制组然后返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// find replicationNum groups that a node is in</span><br><span class="line">private List&lt;PartitionGroup&gt; getPartitionGroups(Node node) &#123;</span><br><span class="line">  List&lt;PartitionGroup&gt; ret = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  int nodeIndex = nodeRing.indexOf(node);</span><br><span class="line">  for (int i = 0; i &lt; replicationNum; i++) &#123;</span><br><span class="line">    // the previous replicationNum nodes (including the node itself) are the headers of the</span><br><span class="line">    // groups the node is in</span><br><span class="line">    int startIndex = nodeIndex - i;</span><br><span class="line">    if (startIndex &lt; 0) &#123;</span><br><span class="line">      startIndex = startIndex + nodeRing.size();</span><br><span class="line">    &#125;</span><br><span class="line">    ret.add(getHeaderGroup(nodeRing.get(startIndex)));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  logger.debug(&quot;The partition groups of &#123;&#125; are: &#123;&#125;&quot;, node, ret);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Slot与node的映射关系计算"><a href="#Slot与node的映射关系计算" class="headerlink" title="Slot与node的映射关系计算"></a>Slot与node的映射关系计算</h2><p>可以详细看如下代码，思路如下：</p>
<ol>
<li>计算出总的node个数： nodeRingSize；</li>
<li>求出配置的totalSlotNumbers，默认是10000个：</li>
<li>则每个node上面分配的slot数量为：slotsPerNode = totalSlotNumbers / nodeRingSize，因为这个结果并不一定是整数，则最后面的一个node上面的slot num个数可能会多一些。所以Map&lt;Node, List<integer>&gt; nodeSlotMap这个数据结构就初始化好了。</integer></li>
<li>有了Map&lt;Node, List<integer>&gt; nodeSlotMap这个数据结构，则每个slot在哪个节点，即Map&lt;Integer, Node&gt; slotNodeMap这个数结构也就很清楚了。</integer></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void assignPartitions() &#123;</span><br><span class="line">  // evenly assign the slots to each node</span><br><span class="line">  int nodeNum = nodeRing.size();</span><br><span class="line">  // 计算出每个节点上面有多少个slot</span><br><span class="line">  int slotsPerNode = totalSlotNumbers / nodeNum;</span><br><span class="line">    for (Node node : nodeRing) &#123;</span><br><span class="line">      nodeSlotMap.put(node, new ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; totalSlotNumbers; i++) &#123;</span><br><span class="line">      int nodeIdx = i / slotsPerNode;</span><br><span class="line">      if (nodeIdx &gt;= nodeNum) &#123;</span><br><span class="line">        // the last node may receive a little more if total slots cannot de divided by node number</span><br><span class="line">        // 对于最后一个节点，则可能会多一些slot</span><br><span class="line">        nodeIdx--;</span><br><span class="line">      &#125;</span><br><span class="line">      // nodeSlotMap key就是node，value就是slot num的list</span><br><span class="line">      nodeSlotMap.get(nodeRing.get(nodeIdx)).add(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // build the index to find a node by slot</span><br><span class="line">  for (Entry&lt;Node, List&lt;Integer&gt;&gt; entry : nodeSlotMap.entrySet()) &#123;</span><br><span class="line">    for (Integer slot : entry.getValue()) &#123;</span><br><span class="line">      // slotNodeMap key是slot id，value是node</span><br><span class="line">      slotNodeMap.put(slot, entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据路由"><a href="#数据路由" class="headerlink" title="数据路由"></a>数据路由</h2><p>以insert数据为例，其数据路由如下：</p>
<ol>
<li>根据要插入数据的storageGroupName以及timestamp 进行hash，确定slotId。算法如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static int calculateStorageGroupSlotByTime(String storageGroupName, long timestamp,</span><br><span class="line">    int slotNum) &#123;</span><br><span class="line">  // 获取partitionId，partitionInstance=timestamp / timePartitionInterval;</span><br><span class="line">  long partitionInstance = StorageEngine.getTimePartition(timestamp);</span><br><span class="line">  // 计算hash值</span><br><span class="line">  int hash = Murmur128Hash.hash(storageGroupName, partitionInstance, HASH_SALT);</span><br><span class="line">  // 对slotNum取模，计算出所属的slotId。</span><br><span class="line">  return Math.abs(hash % slotNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>从slotNodeMap这个map中获取这个slot所在的node；</li>
<li>以此node作为header，寻找这个node作为header的PartitionGroup.</li>
<li>获取此PartitionGroup(其实是用了这个partitionGroup的header)所在的GroupMember，后续对数据的操作皆用此GroupMember对象。(代码在DataGroupMember::getDataMember中，即iotdb为每个header创建了一个DataGroupMember，然后保存在Map&lt;Node, DataGroupMember&gt; headerGroupMap这个数据结构中，所以通过header就可以找到这个header所属的DataGroupMember)。</li>
</ol>
<h1 id="节点管理"><a href="#节点管理" class="headerlink" title="节点管理"></a>节点管理</h1><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><p>增加节点这个操作是MetaClusterServer来处理的，MetaClusterServer收到请求之后，调用MetaGroupMember.joinCluster()来处理，这个函数的处理逻辑如下：</p>
<ol>
<li>从种子节点中随机的选择一个节点(假设选择的为节点A，待加入节点为B，这个操作也是在节点B操作的，节点B执行shell脚本把自己加入到集群中)，把这个添加节点的请求转发给这个节点(节点A)；<ul>
<li>连接节点A,给节点A发送addNode的rpc请求（最终请求到达节点A之后，是MetaGroupMember调用的add方法）；<ul>
<li>节点A首先看本机是否是复制组的leader，如果不是，则把请求转发给leader；否则自己处理；</li>
<li>当发现自己是所在的复制组的leader的时候：<ul>
<li>检查一下节点B的参数与节点A本地的参数是否一致（PartitionInterval、HashSalt、ReplicationNum等），不一致则返回。</li>
<li>构造AddNodeLog，并且把其发送给同一个复制组(目前的实现也就是所有的节点，因为metaDataGroup所有的节点组成了一个复制组)，当大多数节点收到回复的时候，即认为成功；<font color="red">注意：leader发送日志给follower的时候，follower仅仅把日志保存下来，并不去commit日志，commit日志只有在leader与follower通过心跳通信的时候，才让follower去commit日志，然后在走一遍状态机</font></li>
<li>当节点A收到大多数节点的回复的时候，节点A提交日志，提交日志的时候会走状态机，对于AddNodeLog，状态机会更新本地的partitionTabel；</li>
<li>节点A序列化本地最新的partitionTabel，返回给节点B;</li>
</ul>
</li>
</ul>
</li>
<li>若rpc请求返回成功：接受节点A返回的partitionTable信息，然后调用dataGroupMember.pullSnapshot 方法来追赶新复制组的数据。</li>
<li>其他情况下都是失败的，等待重试。</li>
</ul>
</li>
<li>当加入成功之后，设置自己的角色为FOLLOWER，并且启动心跳服务。结束；</li>
<li>若第一步加入失败，则等待1000ms(心跳时间)之后，再次重试，最多重试10次；</li>
</ol>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>删除节点与添加节点逻辑类似，再次不再分析</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/IoTDB/" rel="tag"># IoTDB</a>
          
            <a href="/tags/cluster/" rel="tag"># cluster</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/16/转载-大话-Select、Poll、Epoll/" rel="next" title="[转载]大话 Select、Poll、Epoll">
                <i class="fa fa-chevron-left"></i> [转载]大话 Select、Poll、Epoll
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/15/IOTDB-源码解析-查询/" rel="prev" title="IOTDB-源码解析-查询">
                IOTDB-源码解析-查询 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="伊蓝">
            
              <p class="site-author-name" itemprop="name">伊蓝</p>
              <p class="site-description motion-element" itemprop="description">记录点滴</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">86</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">20</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">132</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/neuyilan/" title="GitHub &rarr; https://github.com/neuyilan/" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Log-相关"><span class="nav-number">1.</span> <span class="nav-text">Log 相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#log"><span class="nav-number">1.1.</span> <span class="nav-text">log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#snapshot解析"><span class="nav-number">1.2.</span> <span class="nav-text">snapshot解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#log-applier"><span class="nav-number">1.3.</span> <span class="nav-text">log applier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#log-manager"><span class="nav-number">1.4.</span> <span class="nav-text">log manager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Server"><span class="nav-number">2.</span> <span class="nav-text">Server</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RaftServer"><span class="nav-number">2.1.</span> <span class="nav-text">RaftServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MetaClusterServer"><span class="nav-number">2.2.</span> <span class="nav-text">MetaClusterServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataClusterServer"><span class="nav-number">2.3.</span> <span class="nav-text">DataClusterServer</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RaftMember"><span class="nav-number">3.</span> <span class="nav-text">RaftMember</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RaftMember中的重点函数解析"><span class="nav-number">3.1.</span> <span class="nav-text">RaftMember中的重点函数解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#心跳算法"><span class="nav-number">3.1.1.</span> <span class="nav-text">心跳算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catchUp函数"><span class="nav-number">3.1.2.</span> <span class="nav-text">catchUp函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选举算法"><span class="nav-number">3.1.3.</span> <span class="nav-text">选举算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#syncLeader函数"><span class="nav-number">3.1.4.</span> <span class="nav-text">syncLeader函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataGroupMember"><span class="nav-number">3.2.</span> <span class="nav-text">DataGroupMember</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MetaGroupMember"><span class="nav-number">3.3.</span> <span class="nav-text">MetaGroupMember</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#详细函数分析"><span class="nav-number">3.3.1.</span> <span class="nav-text">详细函数分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据分布partition"><span class="nav-number">4.</span> <span class="nav-text">数据分布partition</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SlotPartitionTable初始化"><span class="nav-number">4.1.</span> <span class="nav-text">SlotPartitionTable初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#getPartitionGroups函数详解"><span class="nav-number">4.2.</span> <span class="nav-text">getPartitionGroups函数详解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Slot与node的映射关系计算"><span class="nav-number">4.3.</span> <span class="nav-text">Slot与node的映射关系计算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据路由"><span class="nav-number">4.4.</span> <span class="nav-text">数据路由</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#节点管理"><span class="nav-number">5.</span> <span class="nav-text">节点管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#添加节点"><span class="nav-number">5.1.</span> <span class="nav-text">添加节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除节点"><span class="nav-number">5.2.</span> <span class="nav-text">删除节点</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">伊蓝</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v6.7.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=6.7.0"></script>

  <script src="/js/src/motion.js?v=6.7.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=6.7.0"></script>




  
  <script src="/js/src/scrollspy.js?v=6.7.0"></script>
<script src="/js/src/post-details.js?v=6.7.0"></script>



  


  <script src="/js/src/bootstrap.js?v=6.7.0"></script>



  
  




  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function (item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'CCj0VULQMKCDsXgP4pmSrOTo-gzGzoHsz',
    appKey: 'MWSq3U7EEI2dN5qSQKdOMt2X',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false
  });
</script>



  

  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
